return(J)
}
#Intial theta
initial_theta <- rep(0,ncol(X.mat))
#Cost at inital theta
cost(initial_theta)
X = t(X.mat)
#Response variable
Y <- as.matrix(data1[,3])
#Cost Function
cost <- function(theta)
{
m <- nrow(X)
g <- sigmoid(X%*%theta)
J <- (1/m)*sum((-Y*log(g)) - ((1-Y)*log(1-g)))
return(J)
}
#Intial theta
initial_theta <- rep(0,ncol(X.mat))
#Cost at inital theta
cost(initial_theta)
X
#Response variable
Y <- as.matrix(data1[,3])
#Cost Function
cost <- function(theta)
{
m <- nrow(X)
g <- sigmoid(X%*%theta)
J <- (1/m)*sum((-Y*log(g)) - ((1-Y)*log(1-g)))
return(J)
}
#Intial theta
initial_theta <- rep(0,ncol(X.mat))
#Cost at inital theta
cost(initial_theta)
## Cost function and gradient
#Predictor variables
X <- as.matrix(data1[,c(1,2)])
#Add ones to X
X <- cbind(rep(1,nrow(X)),X)
X
X = X.mat
X
#Response variable
Y <- as.matrix(data1[,3])
#Cost Function
cost <- function(theta)
{
m <- nrow(X)
g <- sigmoid(X%*%theta)
J <- (1/m)*sum((-Y*log(g)) - ((1-Y)*log(1-g)))
return(J)
}
#Intial theta
initial_theta <- rep(0,ncol(X.mat))
#Cost at inital theta
cost(initial_theta)
Y
#Response variable
Y <- as.matrix(data2[,3])
#Cost Function
cost <- function(theta)
{
m <- nrow(X)
g <- sigmoid(X%*%theta)
J <- (1/m)*sum((-Y*log(g)) - ((1-Y)*log(1-g)))
return(J)
}
#Intial theta
initial_theta <- rep(0,ncol(X.mat))
#Cost at inital theta
cost(initial_theta)
# Derive theta using gradient descent using optim function
theta_optim <- optim(par=initial_theta,fn=cost)
#set theta
theta <- theta_optim$par
#cost at optimal value of the theta
theta_optim$value
theta
ggplot(data2, aes(x = data2[,1], y= data2[,2],color = pass.or.not)) +
geom_point()+
curve(sin, -2*pi, 2*pi, xname = "t")
ggplot(data2, aes(x = da, y= data2[,2],color = pass.or.not)) +
geom_point()
ggplot(data2, aes(x = x1, y= x2,color = pass.or.not)) +
geom_point()
theta
for ( i in 1:degree){
for(j in 0:i){
(x1^(i-j)*x2^j) * theta[k]
k = k+1
}
}
?stat_function
for ( i in 1:degree){
for(j in 0:i){
print((x1^(i-j)*x2^j) * theta[k])
k = k+1
}
}
k=1
for ( i in 1:degree){
for(j in 0:i){
print((x1^(i-j)*x2^j) * theta[k])
k = k+1
}
}
##2.2 Feature mapping
x1 = data2[,1]
x2 = data2[,2]
X = list()
degree = 6
k=1
for ( i in 1:degree){
for(j in 0:i){
X[[k]] = x1^(i-j)*x2^j
k = k+1
}
}
X
X
length(theta)
theta%*% X
theta
class(theta)
class(X.mat)
as.matrix(theta) %*% X.mat
≈ç
as.matrix(theta)
as.matrix(theta, nrow=1)
theta.mat = as.matrix(theta, nrow=1)
theta.mat %*% X
class(X)
##2.2 Feature mapping
x1 = data2[,1]
x2 = data2[,2]
X = list()
degree = 6
k=1
for ( i in 1:degree){
for(j in 0:i){
X[[k]] = x1^(i-j)*x2^j
k = k+1
}
}
X.mat = c(rep(1,length(x1)))
for (k  in 1:27){
X.mat = cbind(X.mat,X[[k]])
}
X = X.mat
theta.mat %*% X
nrow(theta.mat)
ggplot(data2, aes(x = x1, y= x2,color = pass.or.not)) +
geom_point()+
theta.mat = martix(theta , nrow = 1)
ggplot(data2, aes(x = x1, y= x2,color = pass.or.not)) +
geom_point()+
theta.mat = as.martix(theta , nrow = 1)
##2.2 Feature mapping
x1 = data2[,1]
x2 = data2[,2]
X = list()
degree = 6
k=1
for ( i in 1:degree){
for(j in 0:i){
X[[k]] = x1^(i-j)*x2^j
k = k+1
}
}
X.mat = c(rep(1,length(x1)))
for (k  in 1:27){
X.mat = cbind(X.mat,X[[k]])
}
X = X.mat
#Response variable
Y <- as.matrix(data2[,3])
#Cost Function
cost <- function(theta)
{
m <- nrow(X)
g <- sigmoid(X%*%theta)
J <- (1/m)*sum((-Y*log(g)) - ((1-Y)*log(1-g)))
return(J)
}
#Intial theta
initial_theta <- rep(0,ncol(X.mat))
#Cost at inital theta
cost(initial_theta)
# Derive theta using gradient descent using optim function
theta_optim <- optim(par=initial_theta,fn=cost)
#set theta
theta <- theta_optim$par
#cost at optimal value of the theta
theta_optim$value
ggplot(data2, aes(x = x1, y= x2,color = pass.or.not)) +
geom_point()+
theta.mat = as.martix(theta , nrow = 1)
ggplot(data2, aes(x = x1, y= x2,color = pass.or.not)) +
geom_point()+
theta.mat = as.matrix(theta , nrow = 1)
ggplot(data2, aes(x = x1, y= x2,color = pass.or.not)) +
geom_point()+
theta.mat = as.matrix(theta , nrow = 1)
theta.mat = as.matrix(theta , nrow = 1)
theta.mat
theta.mat = t(as.matrix(theta , nrow = 1))
theta.mat
X
theta.mat %*% X
ncol(theta.mat)
ncol(x)
ncol(X)
theta.mat = as.matrix(theta
)
theta.mat %*% X
theta.mat %*% t(X)
theta.mat
theta.mat = t(as.matrix(theta))
theta.mat %*% t(X)
X
ggplot(data2, aes(x = x1, y= x2,color = pass.or.not)) +
geom_point()+
stat_function(fun=function(x) sin(x) + log(x))
library(readr)
#####1####
data1 = read.delim("Desktop/machine-learning-ex2/ex2/ex2data1.txt",sep=",")
### 1.1 Visualizing the data
library(ggplot2)
pass.or.not = as.factor(data1[,3])
ggplot(data1, aes(x = data1[,1], y= data1[,2],color = pass.or.not)) +
geom_point()
###1.2 Implementation####
library(e1071)
sigmoid(data1)
## Cost function and gradient
#Predictor variables
X <- as.matrix(data1[,c(1,2)])
#Add ones to X
X <- cbind(rep(1,nrow(X)),X)
#Response variable
Y <- as.matrix(data1[,3])
#Cost Function
cost <- function(theta)
{
m <- nrow(X)
g <- sigmoid(X%*%theta)
J <- (1/m)*sum((-Y*log(g)) - ((1-Y)*log(1-g)))
return(J)
}
#Intial theta
initial_theta <- rep(0,ncol(X))
#Cost at inital theta
cost(initial_theta)
# Derive theta using gradient descent using optim function
theta_optim <- optim(par=initial_theta,fn=cost)
#set theta
theta <- theta_optim$par
#cost at optimal value of the theta
theta_optim$value
# probability of admission for student
prob <- sigmoid(t(c(1,67.31926,66.58935))%*%theta)
pass.or.not = as.factor(data1[,3])
ggplot(data1, aes(x = data1[,1], y= data1[,2],color = pass.or.not)) +
geom_point()+
geom_line(aes(x = data1[,1], y =122.285538-0.98288034*data1[,1] ,color = "blue"))
#####2####
##2.1 Visualizing the data
data2 = read.delim("Desktop/machine-learning-ex2/ex2/ex2data2.txt",sep=",")
pass.or.not = as.factor(data2[,3])
ggplot(data2, aes(x = data2[,1], y= data2[,2],color = pass.or.not)) +
geom_point()
##2.2 Feature mapping
x1 = data2[,1]
x2 = data2[,2]
X = list()
degree = 6
k=1
for ( i in 1:degree){
for(j in 0:i){
X[[k]] = x1^(i-j)*x2^j
k = k+1
}
}
X.mat = c(rep(1,length(x1)))
for (k  in 1:27){
X.mat = cbind(X.mat,X[[k]])
}
X = X.mat
#Response variable
Y <- as.matrix(data2[,3])
#Cost Function
cost <- function(theta)
{
m <- nrow(X)
g <- sigmoid(X%*%theta)
J <- (1/m)*sum((-Y*log(g)) - ((1-Y)*log(1-g)))
return(J)
}
#Intial theta
initial_theta <- rep(0,ncol(X.mat))
#Cost at inital theta
cost(initial_theta)
# Derive theta using gradient descent using optim function
theta_optim <- optim(par=initial_theta,fn=cost)
#set theta
theta <- theta_optim$par
#cost at optimal value of the theta
theta_optim$value
ggplot(data2, aes(x = x1, y= x2,color = pass.or.not)) +
geom_point()+
stat_function(fun=function(x) sin(x) + log(x))
ggplot(data2, aes(x = x1, y= x2,color = pass.or.not)) +
geom_point()+
stat_function(fun=function(x) sin(x) + log(y))
ggplot(data2, aes(x = x1, y= x2,color = pass.or.not)) +
geom_point()+
stat_function(fun=function(x,y) sin(x) + log(y))
?stat_function()`
``
?stat_function()
theta_optim$value
theta
theta.mat %*% t(X)
ggplot(data2, aes(x = x1, y= x2,color = pass.or.not)) +
geom_point()+
stat_function(fun=function(x,y) x+y)
ggplot(data2, aes(x = x1, y= x2,color = pass.or.not)) +
geom_point()+
stat_function(fun=function(x) x)
?stat_function()
rawdataset <- read.csv("ex4data1.csv") # x1,x2,y -> csv format
?geom_contour(
)
ggplot(data2, aes(x = data2[,1], y= data2[,2],color = pass.or.not)) +
geom_point()+
geom_contour()
ggplot(data2, aes(x = data2[,1], y= data2[,2],color = pass.or.not)) +
ggplot(data2, aes(x = data2[,1], y= data2[,2],color = pass.or.not)) +
geom_point()+
geom_contour(aes(x=x1, y=x2))
library(ggplot2)
library(dplyr)
source("/Users/supermonk00/Desktop/programing/R/St.Kitts/WS_reg/WS.average_temperature.R")
source("/Users/supermonk00/Desktop/programing/R/St.Kitts/SP_Trial/SP_PivotTable_report.R")
#### (lead in the temperature information)
month_temp = Dailytemperature_calculate(
filename = "Needsmust.csv",
start_day = "2019/10/11",
end_day = "2020/03/23",
including.period = 30,divided.period  = 7)
# insert temperature data, replicate for two variety
temperature = rep(c(month_temp$temperature.average),2)
### set the week data, replicate for two variety
Week = rep(c(1:length(Harvest$Date)),2)
purple = data.frame(Weight = Harvest$weight_purple,Variety = "Purple")
red = data.frame(Weight = Harvest$weight_red, Variety = "Red")
# tidy up to an intergated dataframe #
Dataset_weekly.harvest = data.frame(Week,rbind(purple,red))
# set plot, x-axis
p.overall.harvest = ggplot(data = Dataset_weekly.harvest, aes(x = Week))
# draw barchart
p.overall.harvest = p.overall.harvest + geom_bar(aes(y= Weight,fill = Variety),
stat = "identity",
position="dodge",
width = 0.5)+
scale_fill_manual(values = c("purple", "red"))
ylim.prim <- c(0, 100000)   # in this example, precipitation
ylim.sec <- c(25, 30)    # in this example, temperature
# linear transformation
b <- diff(ylim.prim)/diff(ylim.sec)
a <- b*(ylim.prim[1] - ylim.sec[1])
# draw linegraph
p.overall.harvest = p.overall.harvest +
geom_line(aes(y = a+temperature*b))+
geom_point(aes(y = a+temperature*b))+
theme(axis.title.y = element_text(vjust = 1,size = 15),
axis.title.x = element_text(size = 15))+
scale_y_continuous(name = "Weight(g)",
sec.axis = sec_axis(~(.-a)/b ,name ="Temperature(°C)"))+ #set second axis
scale_x_continuous(name = "Week(2019/11/11-2020/03/23)", breaks = c(Week))+
ggtitle("Sweet Pepper Harvest Overall")
## Purple
lm.p.data = data.frame(temperature = month_temp$temperature.average, weight =Harvest$weight_purple )
lm_p = lm(weight~temperature,data =lm.p.data) %>%
summary()
lm.information.label.p = as.expression(substitute(italic(adj.R)^2 == r, list(r = round(lm_p$adj.r.squared,3))))
p.lm.purple = ggplot(lm.p.data,aes(x =temperature, y  =  weight))+
geom_point()+
labs(x = "Monthly temperature average before harvest",
y = "Weekly harvest(g)")+
geom_smooth(method = "lm", se = FALSE,col = "purple")+
annotate("text", x = 28.5, y = 70000,
label = lm.information.label.p)
## Red
lm.r.data = data.frame(temperature = month_temp$temperature.average, weight =Harvest$weight_red)
lm_r = lm(weight~temperature,data = lm.r.data)%>%
summary()
lm.information.label.r = as.expression(substitute(italic(adj.R)^2 == r, list(r = round(lm_r$adj.r.squared,3))))
p.lm.red = ggplot(lm.r.data,aes(x =temperature, y  =  weight))+
geom_point()+
labs(x = "Monthly temperature average before harvest",
y = "Weekly harvest(g)")+
geom_smooth(method = "lm", se = FALSE,col = "red")+
geom_smooth(method = "loess", se = FALSE,col = "grey")+ # 'cause R-squared (Red) is low, strech the loess line
annotate("text", x = 28.5, y = 25000,
label = lm.information.label.r)+
annotate("segment", x = 26.3, xend = 26.5, y = 5000, yend = 9500, colour = "grey", size=1, alpha=0.9, arrow=arrow())+
annotate("text", x = 26.6, y = 4300,label="Extra:Loess for fitting data",colour = "grey",size=4)
# reform to the plot-acceptable dataframe
Dataset_individual.weight = rbind(
data.frame(Weight = purple_total$`Weight(g)`,Variety ="Purple"),
data.frame(Weight = red_total$`Weight(g)`,Variety = "Red")
)
p.box_weight.distribution = ggplot(Dataset_individual.weight,aes(x = Variety, y=Weight,fill=Variety))+
geom_boxplot(alpha = 0.8)+
scale_fill_manual(values = c("purple", "red"))+
ggtitle("Boxplot: Fruit Weight Distribution")+
ylab("Fruit weight(g)")
Dataset_trimtrial.individual= rbind(
data.frame(Weight = purple_notrim$`Weight(g)`,
Treatment = "notrim"),
data.frame(Weight = purple_trim$`Weight(g)`,
Treatment = "trim"))
# boxplot show the trim/notrim(purple) distribution
p.box_trimtrial = ggplot(data = Dataset_trimtrial.individual, aes(x = Treatment))
p.box_trimtrial = p.box_trimtrial + geom_boxplot(aes(y= Weight))+
labs(title = "Fruit Weight Distribution",
subtitle = "Purple",
y = "Weight(g)")
# t.test for assessment of difference of the average weight
t.test(Dataset_trimtrial.individual$Weight[which(Dataset_trimtrial.individual$Treatment =="notrim")],
Dataset_trimtrial.individual$Weight[which(Dataset_trimtrial.individual$Treatment =="trim")], paired=FALSE)
Dataset_trimtrial.weekly.harvest.p = Harvest_treatment_p %>%
mutate(Week = rep(c(1:4),2))
p.trimtrial.total.weight.p = ggplot(data = Dataset_trimtrial.weekly.harvest.p, aes(x = Week))
p.trimtrial.total.weight.p = p.trimtrial.total.weight.p + geom_bar(aes(y= Weight,fill = Treatment),
stat = "identity",
position="dodge",
width = 0.5)+
scale_fill_manual(values = c("black", "grey"))+
scale_x_continuous(name = "Week(2020/02/24-2020/03/23)", breaks = c(Week))+
ylab("Total weight(g)")+
ggtitle("TrimTrial:Total Weight",subtitle = "Purple")
p.trimtrial.average.weight.p = ggplot(data = Dataset_trimtrial.weekly.harvest.p, aes(x = Week,y = mu,fill = Treatment))+
geom_col(position = 'dodge', width = 0.5)+
scale_fill_manual(values = c("#DCDCDC", "#696969"))+
geom_errorbar(aes(x=Week, ymin=mu-sd, ymax=mu+sd),  # add errorbar
width=0.1, color='black', position = position_dodge(0.5),  # set colors, width of errorbar
size=0.3)+
scale_x_continuous(name = "Week(2020/02/24-2020/03/23)", breaks = c(Week))+
ylab("Average weight(g)")+
ggtitle("TrimTrial:Average Weight",subtitle =  "Purple")
Dataset_trimtrial.weekly.harvest.r = Harvest_treatment_r %>%
mutate(Week = rep(c(1:4),2))
#plot
p.trimtrial.total.weight.r = ggplot(data = Dataset_trimtrial.weekly.harvest.r, aes(x = Week))
p.trimtrial.total.weight.r = p.trimtrial.total.weight.r + geom_bar(aes(y= Weight,fill = Treatment),
stat = "identity",
position="dodge",
width = 0.5)+
scale_fill_manual(values = c("black", "grey"))+
scale_x_continuous(name = "Week(2020/02/24-2020/03/23)", breaks = c(Week))+
ylab("Total weight(g)")+
ggtitle("TrimTrial:Total Weight",subtitle = "Red")
p.trimtrial.average.weight.r = ggplot(data = Dataset_trimtrial.weekly.harvest.r, aes(x = Week,y = mu,fill = Treatment))+
geom_col(position = 'dodge', width = 0.5)+
scale_fill_manual(values = c("#DCDCDC", "#696969"))+
geom_errorbar(aes(x=Week, ymin=mu-sd, ymax=mu+sd),
width=0.1, color='black', position = position_dodge(0.5),
size=0.3)+
scale_x_continuous(name = "Week(2020/02/24-2020/03/23)", breaks = c(Week))+
ylab("Average weight(g)")+
ggtitle("TrimTrial:Average Weight",subtitle =  "Red")
p.box_trimtrial
p.box_weight.distribution
p.lm.purple
p
p.lm.red
p.overall.harvest
p.trimtrial.average.weight.p
p.trimtrial.average.weight.r
p.trimtrial.total.weight.p
p.trimtrial.total.weight.r
###Fruit on plants####
# insert data, hand-written data
FN.purple_trim = c(13,10,18,9,22,8,11,22,24,11,26,27,17,
24,13,20,12,25,21,31)
FN.purple_notrim = c(20,32,24,20,23,19,32,20,25,22)
FN.red_trim = c(2,12,6,4,9,11,5,7,5,5,3,4,8,14,4,8,2,14,21,1)
FN.red_notrim = c(6,6,6,2,6,9,8,7,4,12,3,8,14,7,5,5,6,6,9,5)
#Dataset labeling
FN.dataset = rbind(data.frame(fruit.number = FN.purple_trim,Variety = "purple" ,Treatment = "trim"),
data.frame(fruit.number = FN.purple_notrim, Variety = "purple", Treatment = "notrim"),
data.frame(fruit.number = FN.red_trim, Variety = "red", Treatment = "trim"),
data.frame(fruit.number = FN.red_notrim, Variety = "red", Treatment = "notrim"))
#calculate average, sd
FN.dataset.pivotable = FN.dataset %>%
group_by(Variety,Treatment) %>%
summarise(mu = mean(fruit.number),
sd = sd(fruit.number))
# draw a barplot with errorbar
p.fruit_on_plant = ggplot(data = FN.dataset.pivotable, aes(x = Variety,y = mu,fill = Treatment))+
geom_col(position = 'dodge', width = 0.5)+
scale_fill_manual(values = c("#004D99","#6495ED"))+
geom_errorbar(aes(x=Variety, ymin=mu-sd, ymax=mu+sd),
width=0.1, color='black', position = position_dodge(0.5),
size=0.3)+
labs(title = "Fruit on plant",
x = "Variety", y=  "Number of fruits/plant")
p.fruit_on_plant
